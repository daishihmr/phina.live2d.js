{"version":3,"sources":["phina.live2d.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"phina.live2d.js","sourcesContent":["/*\n * phina.live2d.js 1.0.0\n * https://github.com/daishihmr/phina.live2d.js\n * \n * The MIT License (MIT)\n * Copyright © 2017 daishihmr <daishi.hmr@gmail.com> (http://github.dev7.jp/)\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n * associated documentation files (the “Software”), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following\n * conditions:\n * \n * The above copyright notice and this permission notice shall be included in all copies or substantial portions\n * of the Software.\n * \n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nphina.namespace(function() {\n\n  var Utils = LIVE2DCUBISMCORE.Utils;\n  var tempQuat = quat.create();\n\n  var bufferSize = 4096;\n\n  phina.define(\"phina.live2d.MocAsset\", {\n    superClass: \"phina.asset.Asset\",\n\n    init: function() {\n      this.superInit();\n    },\n\n    _load: function(resolve) {\n      var self = this;\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", this.src);\n      xhr.responseType = \"arraybuffer\";\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          if ([200, 201, 0].indexOf(xhr.status) !== -1) {\n            var data = xhr.response;\n            self.data = LIVE2DCUBISMCORE.Moc.fromArrayBuffer(data);\n            resolve(self);\n          }\n        }\n      };\n      xhr.send(null);\n    },\n  });\n  phina.asset.AssetLoader.assetLoadFunctions[\"live2d.moc\"] = function(key, path) {\n    var asset = phina.live2d.MocAsset();\n    return asset.load(path);\n  };\n\n  phina.define(\"phina.live2d.MotionAsset\", {\n    superClass: \"phina.asset.File\",\n\n    init: function() {\n      this.superInit();\n    },\n\n    _load: function(resolve) {\n      var before = phina.util.Flow(function(r) {\n        this.superMethod(\"_load\", r);\n      }.bind(this));\n\n      before.then(function() {\n        this.data = LIVE2DCUBISMFRAMEWORK.Animation.fromMotion3Json(this.data);\n        resolve(this);\n      }.bind(this));\n    },\n  });\n  phina.asset.AssetLoader.assetLoadFunctions[\"live2d.motion\"] = function(key, path) {\n    var asset = phina.live2d.MotionAsset();\n    return asset.load({\n      path: path,\n      dataType: \"json\",\n    });\n  };\n\n  phina.define(\"phina.live2d.PhysicsAsset\", {\n    superClass: \"phina.asset.File\",\n\n    init: function() {\n      this.superInit();\n    },\n  });\n  phina.asset.AssetLoader.assetLoadFunctions[\"live2d.physics\"] = function(key, path) {\n    var asset = phina.live2d.PhysicsAsset();\n    return asset.load({\n      path: path,\n      dataType: \"json\",\n    });\n  };\n\n  phina.define(\"phina.live2d.Live2DLayer\", {\n    superClass: \"phina.display.Layer\",\n\n    init: function(options) {\n      this.superInit(options);\n      this.domElement = options.domElement || document.createElement(\"canvas\");\n      this.domElement.width = this.width;\n      this.domElement.height = this.height;\n\n      var gl = this.domElement.getContext(\"webgl\", { stencil: true }) || this.domElement.getContext(\"experimental-webgl\", { stencil: true });\n      gl.clearColor(0.0, 0.0, 0.0, 0.0);\n      gl.clearDepth(1);\n      gl.clearStencil(0);\n      gl.enable(gl.BLEND);\n      gl.enable(gl.STENCIL_TEST);\n      gl.cullFace(gl.BACK);\n      gl.viewport(0, 0, this.width, this.height);\n\n      this.gl = gl;\n\n      this.offScreenBuffer = phigl.Framebuffer(gl, bufferSize, bufferSize, {\n        magFilter: gl.LINEAR,\n        minFilter: gl.LINEAR,\n      });\n\n      var screenVs = phigl.VertexShader();\n      screenVs.data = phina.live2d.Live2DLayer.aaVs;\n      var screenFs = phigl.FragmentShader();\n      screenFs.data = phina.live2d.Live2DLayer.aaFs;\n      var screenProgram = phigl.Program(gl)\n        .attach(screenVs)\n        .attach(screenFs)\n        .link();\n      this.screen = phigl.Drawable(gl)\n        .setProgram(screenProgram)\n        .setIndexValues([0, 1, 2, 1, 3, 2])\n        .declareAttributes(\"position\", \"uv\")\n        .setAttributeDataArray([{\n          unitSize: 2,\n          data: [\n            //\n            -0.5, 0.5,\n            //\n            0.5, 0.5,\n            //\n            -0.5, -0.5,\n            //\n            0.5, -0.5,\n          ],\n        }, {\n          unitSize: 2,\n          data: [\n            //\n            0, 1,\n            //\n            1, 1,\n            //\n            0, 0,\n            //\n            1, 0,\n          ],\n        }, ])\n        .declareUniforms(\"mMatrix\", \"vpMatrix\", \"texture\", \"alpha\");\n\n      this.mMatrix = mat4.create();\n      var viewMatrix = mat4.lookAt(mat4.create(), [0, 0, 1], [0, 0, 0], [0, 1, 0]);\n      var projectionMatrix = mat4.ortho(mat4.create(), 0, this.width, this.height, 0, 0.1, 1000);\n      this.vpMatrix = mat4.create();\n      this.vpMatrix = mat4.multiply(this.vpMatrix, viewMatrix, this.vpMatrix);\n      this.vpMatrix = mat4.multiply(this.vpMatrix, projectionMatrix, this.vpMatrix);\n    },\n\n    draw: function(canvas) {\n      var gl = this.gl;\n\n      phigl.Framebuffer.unbind(gl);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n\n      var children = this.children;\n      for (var i = 0; i < children.length; i++) {\n        var model = children[i];\n\n        this.offScreenBuffer.bind();\n        gl.viewport(0, 0, bufferSize, bufferSize);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n        this._drawChildren(model);\n\n        phigl.Framebuffer.unbind(gl);\n        gl.viewport(0, 0, this.width, this.height);\n        mat4.fromRotationTranslationScale(\n          this.mMatrix,\n          quat.fromEuler(tempQuat, 0, 0, model.rotation),\n          [model.x, model.y, 0],\n          [model.scaleX * bufferSize, -model.scaleY * bufferSize, 1]\n        );\n        this.screen.uniforms[\"mMatrix\"].setValue(this.mMatrix);\n        this.screen.uniforms[\"vpMatrix\"].setValue(this.vpMatrix);\n        this.screen.uniforms[\"texture\"].setValue(0).setTexture(this.offScreenBuffer.texture);\n        this.screen.uniforms[\"alpha\"].setValue(children[i]._alpha);\n        this.screen.draw();\n      }\n\n      gl.flush();\n\n      var image = this.domElement;\n      canvas.context.drawImage(image,\n        0, 0, image.width, image.height, -this.width * this.originX, -this.height * this.originY, this.width, this.height\n      );\n    },\n\n    _drawChildren: function(elm) {\n      if (elm.drawWebGL) elm.drawWebGL(this);\n      for (var i = 0; i < elm.children.length; ++i) {\n        this._drawChildren(elm.children[i]);\n      }\n    },\n\n    _static: {\n      aaVs: [\n        \"attribute vec2 position;\",\n        \"attribute vec2 uv;\",\n\n        \"uniform mat4 mMatrix;\",\n        \"uniform mat4 vpMatrix;\",\n\n        \"varying vec2 vUv;\",\n\n        \"void main(void) {\",\n        \"  vUv = uv;\",\n        \"  gl_Position = vpMatrix * mMatrix * vec4(position, 0.0, 1.0);\",\n        \"}\",\n      ].join(\"\\n\"),\n      aaFs: [\n        \"precision mediump float;\",\n\n        \"uniform sampler2D texture;\",\n        \"uniform float alpha;\",\n\n        \"varying vec2 vUv;\",\n\n        \"void main(void){\",\n        \"  vec4 c0 = texture2D(texture, vUv);\",\n        \"  gl_FragColor = c0 * vec4(1.0, 1.0, 1.0, alpha);\",\n        // \"  gl_FragColor = vec4(0.2, 0.2, 0.8, 1.0);\",\n        \"}\",\n      ].join(\"\\n\"),\n    },\n\n  });\n\n  phina.define(\"phina.live2d.Live2DSprite\", {\n    superClass: \"phina.app.Object2D\",\n\n    gl: null,\n    coreModel: null,\n    textures: null,\n    animator: null,\n    physicsRig: null,\n\n    parameters: null,\n\n    canvasWidth: 0,\n    canvasHeight: 0,\n    pixelsPerUnit: 0,\n\n    _alpha: 1,\n\n    init: function(options) {\n      this.superInit(options);\n      options = ({}).$safe(options, phina.live2d.Live2DSprite.defaults);\n      this._initCore(options);\n      this._initAnimator(options);\n      this._initParameters(options);\n      this._initPhisics(options);\n      this.$watch(\"gl\", function() {\n        this._initTextures(options);\n        this._initMeshes(options);\n      });\n      if (options.gl) {\n        this.gl = options.gl;\n      }\n\n      this.canvasWidth = this.coreModel.canvasinfo.CanvasWidth;\n      this.canvasHeight = this.coreModel.canvasinfo.CanvasHeight;\n      this.pixelsPerUnit = this.coreModel.canvasinfo.PixelsPerUnit;\n    },\n\n    onadded: function() {\n      var findGL = function(elm) {\n        if (elm.gl) return elm.gl;\n        else return findGL(elm.parent);\n      };\n      var gl = findGL(this.parent);\n      if (gl) this.gl = gl;\n    },\n\n    _initCore: function(options) {\n      var moc = typeof(options.moc) === \"string\" ? AssetManager.get(\"live2d.moc\", options.moc) : options.moc;\n      this.coreModel = LIVE2DCUBISMCORE.Model.fromMoc(moc.data);\n      console.log(this.coreModel);\n    },\n\n    _initTextures: function(options) {\n      var gl = this.gl;\n      this.textures = options.textures.map(function(texture) {\n        var tex = phigl.Texture(gl, texture);\n        return tex;\n      });\n    },\n\n    _initMeshes: function(options) {\n      var gl = this.gl;\n      var drawables = this.coreModel.drawables;\n      var textures = this.textures;\n      var meshCount = drawables.ids.length;\n      this.meshes = Array.range(0, meshCount)\n        .map(function(m) {\n\n          var vertexPositions = drawables.vertexPositions[m];\n\n          var uvs = drawables.vertexUvs[m];\n          uvs = uvs.slice(0, uvs.length);\n          for (var v = 1; v < uvs.length; v += 2) {\n            uvs[v] = 1 - uvs[v];\n          }\n\n          var mesh = phigl.Drawable(gl)\n            .setProgram(phina.live2d.Live2DSprite.getProgram(gl))\n            .setIndexValues(drawables.indices[m])\n            .declareAttributes(\"vertexPosition\", \"uv\")\n            .setAttributeDataArray([{\n              unitSize: 2,\n              data: vertexPositions,\n            }, {\n              unitSize: 2,\n              data: uvs,\n            }, ], gl.DYNAMIC_DRAW)\n            .declareUniforms(\"visible\", \"texture\", \"opacity\");\n\n          mesh.index = m;\n          mesh.name = drawables.ids[m];\n          mesh.vertexPositions = vertexPositions;\n          mesh.uvs = uvs;\n          mesh.texture = textures[drawables.textureIndices[m]];\n\n          mesh.opacity = drawables.opacities[m];\n          mesh.visible = Utils.hasIsVisibleBit(drawables.dynamicFlags[m]);\n\n          mesh.doubleSided = Utils.hasIsDoubleSidedBit(drawables.constantFlags[m]);\n\n          if (Utils.hasBlendAdditiveBit(drawables.constantFlags[m])) {\n            mesh.blendMode = \"add\";\n          } else if (Utils.hasBlendMultiplicativeBit(drawables.constantFlags[m])) {\n            mesh.blendMode = \"multiply\";\n          }\n\n          return mesh;\n        });\n\n      for (var m = 0; m < meshCount; ++m) {\n        if (drawables.maskCounts[m] > 0) {\n          var maskIndex = drawables.masks[m][0];\n          var maskMesh = this.meshes[maskIndex];\n          if (maskMesh) {\n            maskMesh.isMask = true;\n            this.meshes[m].mask = maskMesh.index;\n          } else {\n            console.warn(\"maskMesh is not defined. (maskIndex = \" + maskIndex + \")\");\n          }\n        } else {\n          this.meshes[m].mask = -1;\n        }\n      }\n\n      this.orderedMeshes = this.meshes.clone();\n    },\n\n    _initAnimator: function(options) {\n      var animatorBuilder = new LIVE2DCUBISMFRAMEWORK.AnimatorBuilder();\n\n      options.animatorLayers.forEach(function(layer) {\n        if (typeof(layer) === \"string\") layer = { name: layer };\n        layer = ({}).$safe(layer, phina.live2d.Live2DSprite.animationLayerDefaults);\n        animatorBuilder.addLayer(layer.name, layer.blender, layer.weight);\n      }.bind(this));\n\n      this.animator = animatorBuilder\n        .setTarget(this.coreModel)\n        .setTimeScale(options.timeScale)\n        .build();\n    },\n\n    _initParameters: function(options) {\n      this.parameters = phina.app.Element().addChildTo(this);\n      this.parameters.spec = {};\n\n      var params = this.coreModel.parameters;\n      Array.range(0, params.count).forEach(function(i) {\n        var id = params.ids[i];\n        var min = params.minimumValues[i];\n        var max = params.maximumValues[i];\n        this.parameters.spec[id] = {\n          defaultValue: params.defaultValues[i],\n          min: min,\n          max: max,\n        };\n        this.parameters.accessor(id, {\n          get: function() {\n            return params.values[i];\n          },\n          set: function(v) {\n            params.values[i] = Math.clamp(v, min, max);\n          },\n        });\n      }.bind(this));\n    },\n\n    _initPhisics: function(options) {\n      if (!options.physics) return;\n\n      var physics = typeof(options.physics) === \"string\" ? AssetManager.get(\"live2d.physics\", options.physics) : options.physics;\n\n      var physicsRigBuilder = new LIVE2DCUBISMFRAMEWORK.PhysicsRigBuilder();\n      physicsRigBuilder.setPhysics3Json(physics.data);\n      this.physicsRig = physicsRigBuilder\n        .setTarget(this.coreModel)\n        .setTimeScale(options.timeScale)\n        .build();\n    },\n\n    isPlaying: function(layerName) {\n      layerName = layerName || \"base\";\n      return this.animator\n        .getLayer(layerName)\n        .isPlaying;\n    },\n\n    play: function(motion, fadeDuration, layerName) {\n      if (typeof(motion) === \"string\") {\n        motion = phina.asset.AssetManager.get(\"live2d.motion\", motion).data;\n      }\n      fadeDuration = fadeDuration || 0;\n      layerName = layerName || \"base\";\n\n      this.animator\n        .getLayer(layerName)\n        .play(motion, fadeDuration);\n    },\n\n    resume: function(layerName) {\n      layerName = layerName || \"base\";\n      return this.animator\n        .getLayer(layerName)\n        .resume();\n    },\n\n    pause: function(layerName) {\n      layerName = layerName || \"base\";\n      return this.animator\n        .getLayer(layerName)\n        .pause();\n    },\n\n    stop: function(layerName) {\n      layerName = layerName || \"base\";\n      return this.animator\n        .getLayer(layerName)\n        .stop();\n    },\n\n    getCurrentTime: function(layerName) {\n      layerName = layerName || \"base\";\n      return this.animator\n        .getLayer(layerName)\n        .currentTime;\n    },\n\n    setCurrentTime: function(layerName, time) {\n      layerName = layerName || \"base\";\n      this.animator\n        .getLayer(layerName)\n        .currentTime = time;\n    },\n\n    update: function(app) {\n      this.animator.updateAndEvaluate(app.deltaTime * 0.001);\n      if (this.physicsRig) {\n        this.physicsRig.updateAndEvaluate(app.deltaTime * 0.001);\n      }\n      this.coreModel.update();\n\n      var sort = false;\n      var drawables = this.coreModel.drawables;\n      for (var m = 0; m < this.meshes.length; ++m) {\n        var mesh = this.meshes[m];\n        mesh.opacity = drawables.opacities[m];\n        mesh.visible = Utils.hasIsVisibleBit(drawables.dynamicFlags[m]);\n        if (Utils.hasVertexPositionsDidChangeBit(drawables.dynamicFlags[m])) {\n          mesh.vertexPositions = drawables.vertexPositions[m];\n          mesh.dirtyVertex = true;\n        }\n        if (Utils.hasRenderOrderDidChangeBit(drawables.dynamicFlags[m])) {\n          sort = true;\n        }\n      }\n\n      if (sort) {\n        this.orderedMeshes.sort(function(lhs, rhs) {\n          return drawables.renderOrders[lhs.index] - drawables.renderOrders[rhs.index];\n        });\n      }\n\n      // this._checkAnimationEnd();\n    },\n\n    _checkAnimationEnd: function() {\n      for (var kv of this.animator._layers) {\n        var name = kv[0];\n        var layer = kv[1];\n        if (layer.isPlaying && layer.currentTime >= layer._animation.duration) {\n          layer.currentTime -= layer._animation.duration;\n          this.flare(\"finishAnimation\", {\n            layer: name,\n          });\n        }\n      }\n    },\n\n    drawWebGL: function(layer) {\n      var gl = this.gl;\n\n      for (var i = 0; i < this.orderedMeshes.length; ++i) {\n        var mesh = this.orderedMeshes[i];\n        if (mesh.dirtyVertex) {\n          mesh.setAttributeDataArray([{\n            unitSize: 2,\n            data: mesh.vertexPositions,\n          }, {\n            unitSize: 2,\n            data: mesh.uvs,\n          }, ], gl.DYNAMIC_DRAW);\n\n          mesh.dirtyVertex = false;\n        }\n        mesh.uniforms[\"visible\"].setValue(mesh.visible ? 1 : 0);\n        mesh.uniforms[\"texture\"].setValue(0).setTexture(mesh.texture);\n        mesh.uniforms[\"opacity\"].setValue(mesh.opacity);\n\n        switch (mesh.blendMode) {\n          case \"add\":\n            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE);\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            break;\n          case \"multiply\":\n            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE);\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            break;\n          default:\n            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n            break;\n        }\n\n        if (mesh.isMask) {\n          gl.stencilFunc(gl.ALWAYS, mesh.index, ~0);\n          gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE);\n        } else if (mesh.mask != -1) {\n          gl.stencilFunc(gl.EQUAL, mesh.mask, ~0);\n          gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n        } else {\n          gl.stencilFunc(gl.ALWAYS, 0, ~0);\n          gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n        }\n\n        if (mesh.doubleSided) {\n          gl.disable(gl.CULL_FACE);\n        } else {\n          gl.enable(gl.CULL_FACE);\n        }\n\n        mesh.draw();\n      }\n    },\n\n    setAlpha: function(v) {\n      this._alpha = v;\n      return this;\n    },\n\n    _accessor: {\n      playing: {\n        get: function() {\n          return this.isPlaying();\n        },\n      },\n      currentTime: {\n        get: function() {\n          return this.getCurrentTime();\n        },\n        set: function(v) {\n          this.setCurrentTime(v);\n        },\n      },\n      alpha: {\n        get: function() {\n          return this._alpha;\n        },\n        set: function(v) {\n          this.setAlpha(v);\n        },\n      },\n    },\n\n    _static: {\n      defaults: {\n        timeScale: 1,\n        animatorLayers: [{\n          name: \"base\",\n          blender: LIVE2DCUBISMFRAMEWORK.BuiltinAnimationBlenders.OVERRIDE,\n          weight: 1,\n        }],\n      },\n\n      animationLayerDefaults: {\n        blender: LIVE2DCUBISMFRAMEWORK.BuiltinAnimationBlenders.OVERRIDE,\n        weight: 1,\n      },\n\n      _programCache: {},\n      _vertexShaderCache: {},\n      _fragmentShaderCache: {},\n\n      getProgram: function(gl) {\n        var id = phigl.GL.getId(gl);\n        if (this._programCache[id] == null) {\n          this._programCache[id] = phigl.Program(gl)\n            .attach(this.getVertexShader(gl))\n            .attach(this.getFragmentShader(gl))\n            .link();\n        }\n        return this._programCache[id];\n      },\n\n      getVertexShader: function(gl) {\n        var id = phigl.GL.getId(gl);\n        if (this._vertexShaderCache[id] == null) {\n          this._vertexShaderCache[id] = phigl.VertexShader();\n          this._vertexShaderCache[id].data = [\n            \"attribute vec2 vertexPosition;\",\n            \"attribute vec2 uv;\",\n\n            \"uniform float visible;\",\n\n            \"varying vec2 vUv;\",\n\n            \"void main(void) {\",\n            \"  vUv = uv;\",\n            \"  if (visible < 0.5) {\",\n            \"    gl_Position = vec4(0.0);\",\n            \"  } else {\",\n            \"    vec3 pos = vec3(vertexPosition, 1.0);\",\n            \"    gl_Position = vec4(pos, 1.0);\",\n            \"  }\",\n            \"}\",\n          ].join(\"\\n\");\n        }\n        return this._vertexShaderCache[id];\n      },\n\n      getFragmentShader: function(gl) {\n        var id = phigl.GL.getId(gl);\n        if (this._fragmentShaderCache[id] == null) {\n          this._fragmentShaderCache[id] = phigl.FragmentShader();\n          this._fragmentShaderCache[id].data = [\n            \"precision mediump float;\",\n\n            \"uniform sampler2D texture;\",\n            \"uniform float opacity;\",\n\n            \"varying vec2 vUv;\",\n\n            \"void main(void) {\",\n            \"  vec4 col = texture2D(texture, vUv) * vec4(1.0, 1.0, 1.0, opacity);\",\n            \"  if (col.a == 0.0) discard;\",\n            \"  gl_FragColor = col;\",\n            \"}\",\n          ].join(\"\\n\");\n        }\n        return this._fragmentShaderCache[id];\n      },\n    },\n  });\n\n});"]}